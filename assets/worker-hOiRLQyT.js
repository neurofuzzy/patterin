(function(){"use strict";class c{constructor(t,e){this.x=t,this.y=e}add(t){return new c(this.x+t.x,this.y+t.y)}subtract(t){return new c(this.x-t.x,this.y-t.y)}multiply(t){return new c(this.x*t,this.y*t)}divide(t){return t===0?new c(0,0):new c(this.x/t,this.y/t)}normalize(){const t=this.length();return t===0?new c(0,0):this.divide(t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}angle(){return Math.atan2(this.y,this.x)}distanceTo(t){return this.subtract(t).length()}rotate(t){const e=Math.cos(t),s=Math.sin(t);return new c(this.x*e-this.y*s,this.x*s+this.y*e)}perpendicular(){return new c(-this.y,this.x)}perpendicularCW(){return new c(this.y,-this.x)}lerp(t,e){return new c(this.x+(t.x-this.x)*e,this.y+(t.y-this.y)*e)}equals(t,e=1e-10){return Math.abs(this.x-t.x)<e&&Math.abs(this.y-t.y)<e}negate(){return new c(-this.x,-this.y)}clone(){return new c(this.x,this.y)}toString(){return`Vector2(${this.x}, ${this.y})`}static zero(){return new c(0,0)}static one(){return new c(1,1)}static up(){return new c(0,-1)}static down(){return new c(0,1)}static left(){return new c(-1,0)}static right(){return new c(1,0)}static fromAngle(t){return new c(Math.cos(t),Math.sin(t))}}class x{constructor(t,e){this.x=t,this.y=e,this._normal=null,this.prevSegment=null,this.nextSegment=null}get position(){return new c(this.x,this.y)}set position(t){this.x=t.x,this.y=t.y,this.invalidateNormal()}get normal(){return this._normal===null&&(this._normal=this.computeNormal()),this._normal}invalidateNormal(){this._normal=null}computeNormal(){if(!this.prevSegment&&!this.nextSegment)return c.zero();if(this.prevSegment&&this.nextSegment){const t=this.prevSegment.normal,e=this.nextSegment.normal,s=t.add(e);return s.length()<1e-10?t:s.normalize()}return this.prevSegment?this.prevSegment.normal:this.nextSegment?this.nextSegment.normal:c.zero()}moveAlongNormal(t){const e=this.normal;this.x+=e.x*t,this.y+=e.y*t,this.invalidateNormal()}clone(){return new x(this.x,this.y)}equals(t,e=1e-10){return this.position.equals(t.position,e)}toString(){return`Vertex(${this.x}, ${this.y})`}static fromVector(t){return new x(t.x,t.y)}}class v{constructor(t,e){this.start=t,this.end=e,this._normal=null,this._winding="ccw",this.next=null,this.prev=null,this.start.nextSegment=this,this.end.prevSegment=this}get winding(){return this._winding}set winding(t){this._winding!==t&&(this._winding=t,this._normal=null)}get normal(){return this._normal===null&&(this._normal=this.computeNormal()),this._normal}invalidateNormal(){this._normal=null,this.start.invalidateNormal(),this.end.invalidateNormal()}computeNormal(){const t=this.direction();return this._winding==="ccw"?t.perpendicularCW():t.perpendicular()}length(){return this.start.position.distanceTo(this.end.position)}direction(){return this.end.position.subtract(this.start.position).normalize()}directionRaw(){return this.end.position.subtract(this.start.position)}midpoint(){return this.start.position.lerp(this.end.position,.5)}pointAt(t){return this.start.position.lerp(this.end.position,t)}isDegenerate(t=1e-10){return this.length()<t}clone(){return new v(this.start.clone(),this.end.clone())}toString(){return`Segment(${this.start} -> ${this.end})`}intersect(t){const e=this.start.position,s=this.end.position,n=t.start.position,i=t.end.position,o=s.subtract(e),r=i.subtract(n),h=o.cross(r);if(Math.abs(h)<1e-10)return null;const l=n.subtract(e),u=l.cross(r)/h,d=l.cross(o)/h;return u>=0&&u<=1&&d>=0&&d<=1?e.add(o.multiply(u)):null}intersectRay(t,e){const s=this.start.position,n=this.end.position,i=e,o=n.subtract(s),r=i.cross(o);if(Math.abs(r)<1e-10)return null;const h=s.subtract(t),l=h.cross(o)/r,u=h.cross(i)/r;return l>=0&&u>=0&&u<=1?t.add(i.multiply(l)):null}}class S{constructor(t,e="ccw"){this.segments=t,this.winding=e,this.ephemeral=!1,this.open=!1;for(const s of t)s.winding=e}get vertices(){return this.segments.map(t=>t.start)}get closed(){if(this.segments.length===0)return!1;const t=this.segments[0],e=this.segments[this.segments.length-1];return e.end===t.start||e.end.equals(t.start)}get length(){return this.segments.length}area(){let t=0;for(const e of this.segments){const s=e.start.position,n=e.end.position;t+=s.x*n.y-n.x*s.y}return t/2}centroid(){const t=this.vertices;if(t.length===0)return c.zero();let e=0,s=0;for(const n of t)e+=n.x,s+=n.y;return new c(e/t.length,s/t.length)}boundingBox(){const t=this.vertices;if(t.length===0)return{min:c.zero(),max:c.zero(),width:0,height:0,center:c.zero()};let e=1/0,s=1/0,n=-1/0,i=-1/0;for(const h of t)e=Math.min(e,h.x),s=Math.min(s,h.y),n=Math.max(n,h.x),i=Math.max(i,h.y);const o=new c(e,s),r=new c(n,i);return{min:o,max:r,width:n-e,height:i-s,center:o.lerp(r,.5)}}reverse(){if(this.segments.length===0)return;const t=this.vertices.map(s=>s.clone());t.reverse();const e=[];for(let s=0;s<t.length;s++){const n=(s+1)%t.length;e.push(new v(t[s],t[n]))}this.winding=this.winding==="ccw"?"cw":"ccw",this.segments=e,this.connectSegments()}connectSegments(){const t=this.segments.length;if(t!==0){for(let e=0;e<t;e++){const s=this.segments[e];s.winding=this.winding,s.next=this.segments[(e+1)%t],s.prev=this.segments[(e-1+t)%t]}for(const e of this.segments)e.start.nextSegment=e,e.end.prevSegment=e;for(const e of this.segments)e.invalidateNormal()}}validate(){const t=[];if(this.segments.length===0)return t.push("Shape has no segments"),{valid:!1,errors:t};this.closed||t.push("Shape is not closed");for(let e=0;e<this.segments.length;e++){const s=this.segments[e],n=this.segments[(e+1)%this.segments.length];s.end.equals(n.start)||t.push(`Segment ${e} end does not match segment ${e+1} start`)}for(let e=0;e<this.segments.length;e++)this.segments[e].isDegenerate()&&t.push(`Segment ${e} is degenerate (zero length)`);return{valid:t.length===0,errors:t}}removeDegenerate(t=1e-10){this.segments=this.segments.filter(e=>!e.isDegenerate(t)),this.segments.length>0&&this.connectSegments()}clone(){const t=this.vertices.map(n=>n.clone()),e=[];for(let n=0;n<t.length;n++){const i=(n+1)%t.length;e.push(new v(t[n],t[i]))}const s=new S(e,this.winding);return s.ephemeral=this.ephemeral,s.open=this.open,s.group=this.group,s.color=this.color,s.connectSegments(),s}scale(t,e){const s=e??this.centroid();for(const n of this.vertices){const i=n.position.subtract(s);n.position=s.add(i.multiply(t))}for(const n of this.segments)n.invalidateNormal()}rotate(t,e){const s=e??this.centroid();for(const n of this.vertices){const i=n.position.subtract(s);n.position=s.add(i.rotate(t))}for(const n of this.segments)n.invalidateNormal()}translate(t){for(const e of this.vertices)e.position=e.position.add(t)}moveTo(t){const e=this.centroid(),s=t.subtract(e);this.translate(s)}containsPoint(t,e=1e-10){if(this.vertices.length<3)return!1;const n=this.containsPointInternal(t,e);if(this.isNearVertex(t,e*100)){const i=[new c(t.x,t.y+e*10),new c(t.x,t.y-e*10),new c(t.x+e*10,t.y)];let o=n?1:0;for(const r of i)this.containsPointInternal(r,e)&&o++;return o>=2}return n}isNearVertex(t,e){for(const s of this.vertices)if(t.distanceTo(s.position)<e)return!0;return!1}containsPointInternal(t,e){const s=this.vertices;let n=!1;for(let i=0,o=s.length-1;i<s.length;o=i++){const r=s[i].position,h=s[o].position;r.y>t.y!=h.y>t.y&&t.x<(h.x-r.x)*(t.y-r.y)/(h.y-r.y+e)+r.x&&(n=!n)}return n}toPathData(){if(this.segments.length===0)return"";const t=this.vertices,e=[];e.push(`M ${t[0].x} ${t[0].y}`);for(let s=1;s<t.length;s++)e.push(`L ${t[s].x} ${t[s].y}`);return this.open||e.push("Z"),e.join(" ")}toString(){return`Shape(${this.segments.length} segments, ${this.winding})`}static fromPoints(t,e="ccw"){if(t.length<3)throw new Error("Shape requires at least 3 points");const s=t.map(o=>new x(o.x,o.y)),n=[];for(let o=0;o<s.length;o++){const r=(o+1)%s.length;n.push(new v(s[o],s[r]))}const i=new S(n,e);return i.connectSegments(),i}static regularPolygon(t,e,s=c.zero(),n=0){if(t<3)throw new Error("Polygon requires at least 3 sides");const i=[];for(let o=0;o<t;o++){const r=n+o/t*Math.PI*2;i.push(new c(s.x+Math.cos(r)*e,s.y+Math.sin(r)*e))}return S.fromPoints(i,"ccw")}}class P{constructor(t,e="repeat",s=Date.now()){this.values=t,this.mode=e,this.index=0,this.direction=1,this.completed=!1,this.accumulator=0,this.originalSeed=s,this.prng=this.createPRNG(s),this.shuffled=[...t],e==="additive"?this.accumulator=0:e==="multiplicative"&&(this.accumulator=1),e==="shuffle"&&(this.shuffled=this.shuffle(t))}createPRNG(t){let e=t;return function(){e|=0,e=e+1831565813|0;let s=Math.imul(e^e>>>15,1|e);return s=s+Math.imul(s^s>>>7,61|s)^s,((s^s>>>14)>>>0)/4294967296}}shuffle(t){const e=[...t];for(let s=e.length-1;s>0;s--){const n=Math.floor(this.prng()*(s+1));[e[s],e[n]]=[e[n],e[s]]}return e}getNextIndex(){return this.mode==="once"&&this.completed?this.index:this.mode==="additive"||this.mode==="multiplicative"?(this.index++,this.index>=this.values.length&&(this.index=0),this.index):(this.mode==="yoyo"?(this.index+=this.direction,this.index>=this.values.length-1?this.direction=-1:this.index<=0&&(this.direction=1)):this.mode==="random"?(this.index++,this.index>=this.shuffled.length&&(this.shuffled=this.shuffle(this.values),this.index=0)):(this.index++,this.index>=this.values.length&&(this.mode==="once"?(this.completed=!0,this.index=this.values.length-1):this.index=0)),this.index)}resolveValue(t){return typeof t=="function"&&"current"in t?t.current:t}createFunction(){const t=(()=>{if(this.mode==="additive"||this.mode==="multiplicative"){const n=this.resolveValue(this.values[this.index%this.values.length]);this.mode==="additive"?this.accumulator+=n:this.accumulator*=n;const i=this.accumulator;return this.getNextIndex(),i}const e=this.mode==="shuffle"||this.mode==="random"?this.shuffled:this.values,s=this.resolveValue(e[this.index%e.length]);return this.getNextIndex(),s}).bind(this);return Object.defineProperty(t,"current",{get:()=>{if(this.mode==="additive"||this.mode==="multiplicative")return this.accumulator;const e=this.mode==="shuffle"||this.mode==="random"?this.shuffled:this.values;return this.resolveValue(e[this.index%e.length])},enumerable:!0}),t.reset=()=>(this.index=0,this.direction=1,this.completed=!1,this.mode==="additive"?this.accumulator=0:this.mode==="multiplicative"&&(this.accumulator=1),this.prng=this.createPRNG(this.originalSeed),(this.mode==="shuffle"||this.mode==="random")&&(this.shuffled=this.shuffle(this.values)),t),t.peek=(e=0)=>{if(this.mode==="additive"||this.mode==="multiplicative"){let n=this.accumulator,i=this.index;for(let o=0;o<e;o++){i=(i+1)%this.values.length;const r=this.resolveValue(this.values[i]);this.mode==="additive"?n+=r:n*=r}return n}const s=this.mode==="shuffle"||this.mode==="random"?this.shuffled:this.values;return this.resolveValue(s[(this.index+e)%s.length])},t}static repeat(...t){return new P(t,"repeat").createFunction()}static yoyo(...t){return new P(t,"yoyo").createFunction()}static once(...t){return new P(t,"once").createFunction()}static shuffle(t,...e){return typeof t=="number"&&e.length>0?new P(e,"shuffle",t).createFunction():new P([t,...e],"shuffle").createFunction()}static random(t,...e){return typeof t=="number"&&e.length>0?new P(e,"random",t).createFunction():new P([t,...e],"random").createFunction()}static additive(...t){return new P(t,"additive").createFunction()}static multiplicative(...t){return new P(t,"multiplicative").createFunction()}}const F={repeat(...y){return P.repeat(...y)},yoyo(...y){return P.yoyo(...y)},once(...y){return P.once(...y)},shuffle(y,...t){return P.shuffle(y,...t)},random(y,...t){return P.random(y,...t)},additive(...y){return P.additive(...y)},multiplicative(...y){return P.multiplicative(...y)}},Y=class Y{constructor(t,...e){if(this.modifiers=[],this.defaultSaturation=70,this.defaultLightness=50,this._cachedColors=null,this._index=0,t<=0)throw new Error("Color count must be positive");if(e.length===0)throw new Error("At least one zone must be specified");this.totalColors=t,this.zones=e}areZonesAdjacent(t,e){const s=Y.ZONE_DEFINITIONS[t],n=Y.ZONE_DEFINITIONS[e];return s.hueEnd===n.hueStart||n.hueEnd===s.hueStart||s.hueEnd===360&&n.hueStart===0||n.hueEnd===360&&s.hueStart===0}areAllZonesAdjacent(){if(this.zones.length<=1)return!0;const t=[...this.zones].sort((e,s)=>Y.ZONE_DEFINITIONS[e].hueStart-Y.ZONE_DEFINITIONS[s].hueStart);for(let e=0;e<t.length-1;e++)if(!this.areZonesAdjacent(t[e],t[e+1]))return!1;return!0}getBlendedHueRange(){const t=this.zones.map(n=>Y.ZONE_DEFINITIONS[n]),e=t.map(n=>n.hueStart),s=t.map(n=>n.hueEnd);return{start:Math.min(...e),end:Math.max(...s)}}generateHues(){const t=[];if(this.areAllZonesAdjacent()){const e=this.getBlendedHueRange(),s=e.end-e.start,n=s*.1,o=(s-2*n)/(this.totalColors-1||1);for(let r=0;r<this.totalColors;r++){const h=e.start+n+o*r;t.push(h%360)}}else{const e=Math.floor(this.totalColors/this.zones.length),s=this.totalColors%this.zones.length;for(let n=0;n<this.zones.length;n++){const i=this.zones[n],o=Y.ZONE_DEFINITIONS[i],r=e+(n<s?1:0),h=o.hueEnd-o.hueStart,l=h*.1,u=h-2*l,d=r>1?u/(r-1):0;for(let a=0;a<r;a++){const f=o.hueStart+l+d*a;t.push(f%360)}}}return t}applyModifiers(t){const{h:e}=t;let{s,l:n}=t;for(const i of this.modifiers)i.type==="saturation"?s=Math.max(0,Math.min(100,s+i.delta)):i.type==="lightness"&&(n=Math.max(0,Math.min(100,n+i.delta)));return{h:e,s,l:n}}hslToHex(t){const{h:e,s,l:n}=t,i=s/100,o=n/100,r=(1-Math.abs(2*o-1))*i,h=r*(1-Math.abs(e/60%2-1)),l=o-r/2;let u=0,d=0,a=0;e>=0&&e<60?(u=r,d=h,a=0):e>=60&&e<120?(u=h,d=r,a=0):e>=120&&e<180?(u=0,d=r,a=h):e>=180&&e<240?(u=0,d=h,a=r):e>=240&&e<300?(u=h,d=0,a=r):(u=r,d=0,a=h);const f=p=>Math.round((p+l)*255).toString(16).padStart(2,"0");return`#${f(u)}${f(d)}${f(a)}`}muted(t=.2){return this.modifiers.push({type:"saturation",delta:-t*100}),this}vibrant(t=.2){return this.modifiers.push({type:"saturation",delta:t*100}),this}darkMode(t=.3){return this.modifiers.push({type:"lightness",delta:t*100}),this}lightMode(t=.3){return this.modifiers.push({type:"lightness",delta:-t*100}),this}toArray(){return this.generateHues().map(e=>{const s={h:e,s:this.defaultSaturation,l:this.defaultLightness},n=this.applyModifiers(s);return this.hslToHex(n)})}toObject(){const t=this.toArray(),e=["primary","secondary","tertiary","quaternary","quinary","senary"],s={};return t.forEach((n,i)=>{const o=i<e.length?e[i]:`color${i+1}`;s[o]=n}),s}toCss(t="color"){return this.toArray().map((s,n)=>`--${t}-${n+1}: ${s};`).join(" ")}getColors(){return this._cachedColors||(this._cachedColors=this.toArray()),this._cachedColors}get current(){return this.getColors()[this._index]}peek(t=0){const e=this.getColors(),s=(this._index+t)%e.length;return e[s]}reset(){return this._index=0,this}next(){const t=this.getColors(),e=t[this._index];return this._index=(this._index+1)%t.length,e}shuffle(t){const e=this.toArray();return t!==void 0?F.shuffle(t,...e):F.shuffle(e[0],...e.slice(1))}yoyo(){return F.yoyo(...this.toArray())}random(t){const e=this.toArray();return t!==void 0?F.random(t,...e):F.random(...e)}};Y.ZONE_DEFINITIONS={reds:{name:"reds",hueStart:0,hueEnd:30},oranges:{name:"oranges",hueStart:30,hueEnd:60},yellows:{name:"yellows",hueStart:60,hueEnd:90},greens:{name:"greens",hueStart:90,hueEnd:150},cyans:{name:"cyans",hueStart:150,hueEnd:210},blues:{name:"blues",hueStart:210,hueEnd:270},purples:{name:"purples",hueStart:270,hueEnd:300},magentas:{name:"magentas",hueStart:300,hueEnd:360}};let T=Y;const et={create(y,...t){return new T(y,...t)}},I={connection:{stroke:"#39c",strokeWidth:.5},placement:{stroke:"#c93",strokeWidth:1},shape:{stroke:"#c93",strokeWidth:1},line:{stroke:"#c93",strokeWidth:.5}};class L{constructor(){this.paths=[],this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this._segmentCount=0,this.renderMode="stroke",this.colorIndex=0,this.defaultPalette=new T(16,"reds","oranges","yellows","greens","cyans","blues","purples","magentas").toArray()}addPath(t,e={}){this.validatePathData(t),this.paths.push({d:t,style:e,group:this.currentGroup}),this.updateBoundsFromPath(t);const s=t.match(/[LlHhVvCcSsQqTtAaZz]/g);s&&(this._segmentCount+=s.length)}validatePathData(t,e){if(t.includes("NaN")||t.includes("Infinity")){const s=(e==null?void 0:e.constructor.name)||"shape";throw new Error(`Invalid coordinates detected (NaN or Infinity) in ${s}. This usually means a mathematical operation failed (division by zero, invalid scale factor, etc.).`)}}addShape(t,e={}){if(t.ephemeral)return;let s=t.color;s||(s=this.defaultPalette[this.colorIndex%this.defaultPalette.length],this.colorIndex++);const i={...this.applyRenderMode(s),...e},o=t.toPathData();this.validatePathData(o,t),this.addPath(o,i)}beginGroup(t){this.currentGroup=t}endGroup(){this.currentGroup=void 0}setRenderMode(t){this.renderMode=t}getRenderMode(){return this.renderMode}applyRenderMode(t){switch(this.renderMode){case"fill":return{fill:t,stroke:"none"};case"stroke":return{fill:"none",stroke:t,strokeWidth:1};case"glass":return{fill:t,fillOpacity:.5,stroke:t,strokeWidth:1}}}updateBoundsFromPath(t){const e=/[ML]\s*(-?\d+\.?\d*)\s+(-?\d+\.?\d*)/gi;let s;for(;(s=e.exec(t))!==null;){const n=parseFloat(s[1]),i=parseFloat(s[2]);this.minX=Math.min(this.minX,n),this.minY=Math.min(this.minY,i),this.maxX=Math.max(this.maxX,n),this.maxY=Math.max(this.maxY,i)}}getBounds(t=0){return this.paths.length===0||this.minX===1/0?{x:0,y:0,width:100,height:100}:{x:this.minX-t,y:this.minY-t,width:this.maxX-this.minX+t*2,height:this.maxY-this.minY+t*2}}toString(t={}){const{margin:e=10,background:s,autoScale:n=!0,flatten:i=!1}=t;let o=t.width??100,r=t.height??100;const h=this.getBounds(e);t.width||(o=h.width),t.height||(r=h.height);const l=[];if(i||!n){l.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${o}" height="${r}">`);let u=1,d=0,a=0;if(n&&h.width>0&&h.height>0){const f=o/h.width,p=r/h.height;u=Math.min(f,p);const g=h.width*u,_=h.height*u;d=(o-g)/2-h.x*u,a=(r-_)/2-h.y*u}s&&l.push(`  <rect x="0" y="0" width="${o}" height="${r}" fill="${s}"/>`),this.renderPathsGrouped(l,f=>{const p=this.transformPathData(f.d,u,d,a);return this.renderPathWithData(p,f.style)})}else{const u=`${h.x} ${h.y} ${h.width} ${h.height}`;l.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="${u}" width="${o}" height="${r}">`),s&&l.push(`  <rect x="${h.x}" y="${h.y}" width="${h.width}" height="${h.height}" fill="${s}"/>`),this.renderPathsGrouped(l,d=>this.renderPath(d))}return l.push("</svg>"),l.join(`
`)}renderPathsGrouped(t,e){const s=[];let n,i=[];for(const o of this.paths)o.group!==n?(i.length>0&&s.push({name:n,paths:i}),n=o.group,i=[o]):i.push(o);i.length>0&&s.push({name:n,paths:i});for(const o of s)if(o.name){t.push(`  <g id="${o.name}">`);for(const r of o.paths)t.push(`    ${e(r)}`);t.push("  </g>")}else for(const r of o.paths)t.push(`  ${e(r)}`)}transformPathData(t,e,s,n){return t.replace(/([ML])\s*(-?\d+\.?\d*(?:e[+-]?\d+)?)\s+(-?\d+\.?\d*(?:e[+-]?\d+)?)/gi,(i,o,r,h)=>{const l=parseFloat(r)*e+s,u=parseFloat(h)*e+n;return`${o} ${l} ${u}`})}renderPathWithData(t,e){const s=[`d="${t}"`];return e.fill!==void 0?s.push(`fill="${e.fill}"`):s.push('fill="none"'),e.stroke!==void 0&&s.push(`stroke="${e.stroke}"`),e.strokeWidth!==void 0&&s.push(`stroke-width="${e.strokeWidth}"`),e.opacity!==void 0&&s.push(`opacity="${e.opacity}"`),e.fillOpacity!==void 0&&s.push(`fill-opacity="${e.fillOpacity}"`),e.strokeOpacity!==void 0&&s.push(`stroke-opacity="${e.strokeOpacity}"`),e.dash&&e.dash.length>0&&s.push(`stroke-dasharray="${e.dash.join(" ")}"`),`<path ${s.join(" ")}/>`}renderPath(t){const e=[`d="${t.d}"`],s=t.style;return s.fill!==void 0?e.push(`fill="${s.fill}"`):e.push('fill="none"'),s.stroke!==void 0&&e.push(`stroke="${s.stroke}"`),s.strokeWidth!==void 0&&e.push(`stroke-width="${s.strokeWidth}"`),s.opacity!==void 0&&e.push(`opacity="${s.opacity}"`),s.fillOpacity!==void 0&&e.push(`fill-opacity="${s.fillOpacity}"`),s.strokeOpacity!==void 0&&e.push(`stroke-opacity="${s.strokeOpacity}"`),s.dash&&s.dash.length>0&&e.push(`stroke-dasharray="${s.dash.join(" ")}"`),`<path ${e.join(" ")}/>`}get stats(){return{shapes:this.paths.length,segments:this._segmentCount}}clear(){this.paths=[],this._segmentCount=0,this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}get length(){return this.paths.length}}class j{constructor(t,e){this._position=t,this._parentShape=e}get position(){return this._position}get x(){return this._position.x}get y(){return this._position.y}get isOrphan(){return!this._parentShape}expand(t,e=32){const s=S.regularPolygon(e,t);return s.moveTo(this._position),s}raycast(t,e){let s;if(typeof e=="number")s=e*Math.PI/180;else if(this._parentShape){const i=this._parentShape.vertices.find(o=>o.position.equals(this._position));if(i){const o=i.normal;s=Math.atan2(o.y,o.x),e==="inward"&&(s+=Math.PI)}else{const r=this._parentShape.centroid().subtract(this._position).normalize();s=Math.atan2(r.y,r.x),e==="outward"&&(s+=Math.PI)}}else throw new Error("Orphan point requires explicit direction angle");const n=new c(this._position.x+Math.cos(s)*t,this._position.y+Math.sin(s)*t);return new j(n)}}function rt(y,t,e,s){const n=new L,i=s.flatMap(m=>m.items);if(i.length===0)return n.toString({width:y,height:t});let o=1/0,r=1/0,h=-1/0,l=-1/0;for(const m of i){const w=m.shape.boundingBox();o=Math.min(o,w.min.x),r=Math.min(r,w.min.y),h=Math.max(h,w.max.x),l=Math.max(l,w.max.y)}const u=h-o||1,d=l-r||1,a=y-e*2,f=t-e*2,p=Math.min(a/u,f/d),g=e+(a-u*p)/2-o*p,_=e+(f-d*p)/2-r*p;for(const m of s)if(m.items.length!==0){n.beginGroup(m.name);for(const w of m.items){const k=w.shape.clone();k.scale(p),k.translate(new c(g,_)),n.addShape(k,w.style??m.defaultStyle)}n.endGroup()}return n.toString({width:y,height:t})}class B{constructor(){this._placements=[],this._traced=!1}place(t,e){const s=this.getNodes();for(const n of s){const i=t.shape.clone();i.ephemeral=!1,i.moveTo(n.position),this._placements.push({position:n.position,shape:i,style:e})}return t.shape.ephemeral=!0,this}mask(t){t.shape.ephemeral=!0;const e=t.shape;return this._placements=this._placements.filter(s=>e.containsPoint(s.position)),this.filterByMask(e),this}get shapes(){const t=this._placements.map(e=>e.shape.clone());return new M(t)}get length(){return this._placements.length>0?this._placements.length:this.getSourceForSelection().length}every(t,e=0){const s=this._placements.length>0?this._placements.map(i=>i.shape):this.getSourceForSelection(),n=[];for(let i=e;i<s.length;i+=t)n.push(s[i]);return new M(n)}slice(t,e){const s=this._placements.length>0?this._placements.map(n=>n.shape):this.getSourceForSelection();return new M(s.slice(t,e))}scale(t){for(const e of this._placements)e.shape.scale(t);return this.scaleGeometry(t),this}rotate(t){const e=t*Math.PI/180;for(const s of this._placements)s.shape.rotate(e);return this.rotateGeometry(e),this}getBounds(){let t=1/0,e=1/0,s=-1/0,n=-1/0;const i=this.getGeometryBounds();t=Math.min(t,i.minX),e=Math.min(e,i.minY),s=Math.max(s,i.maxX),n=Math.max(n,i.maxY);for(const o of this._placements){const r=o.shape.boundingBox();t=Math.min(t,r.min.x),e=Math.min(e,r.min.y),s=Math.max(s,r.max.x),n=Math.max(n,r.max.y)}return{minX:t,minY:e,maxX:s,maxY:n}}trace(){return this._traced=!0,this}stamp(t,e){const s=e??I.placement;if(this.stampGeometry(t,e),this._placements.length>0){t.beginGroup("placements");for(const n of this._placements)t.addShape(n.shape,n.style??s);t.endGroup()}}toSVG(t){const{width:e,height:s,margin:n=10}=t,i=this.getGeometryRenderGroups(),o=this._placements.map(h=>({shape:h.shape,style:h.style})),r=[...i,{name:"placements",items:o,defaultStyle:I.placement}];return rt(e,s,n,r)}filterEdgesByMask(t,e){return t.filter(s=>e.containsPoint(s.midpoint()))}boundsFromPositions(t){let e=1/0,s=1/0,n=-1/0,i=-1/0;for(const o of t)e=Math.min(e,o.x),s=Math.min(s,o.y),n=Math.max(n,o.x),i=Math.max(i,o.y);return{minX:e,minY:s,maxX:n,maxY:i}}}class z extends B{constructor(t,e){super(),this._shapes=[],this._nodes=[],this._segments=[],this._source=t,this._options=e,this._ephemeral=!1,this._computeGeometry()}static fromShape(t,e,s=0,n=0){return new z(t,{count:e,offsetX:s,offsetY:n})}_computeGeometry(){const t=new c(this._options.offsetX,this._options.offsetY),e=this._options.count;if(this._source instanceof S)for(let s=0;s<=e;s++){const n=this._source.clone();n.ephemeral=!1,n.translate(t.multiply(s)),this._shapes.push(n),this._nodes.push(new x(n.centroid().x,n.centroid().y))}else{const s=this._source.shapes;for(let n=0;n<=e;n++)for(const i of s.shapes){const o=i.clone();o.ephemeral=!1,o.translate(t.multiply(n)),this._shapes.push(o),this._nodes.push(new x(o.centroid().x,o.centroid().y))}}this._buildPathSegments()}_buildPathSegments(){if(this._source instanceof S)for(let t=0;t<this._nodes.length-1;t++)this._segments.push(new v(this._nodes[t],this._nodes[t+1]));else{const t=this._source.shapes.length,e=this._options.count+1;for(let s=0;s<e;s++){const n=s*t;for(let i=0;i<t-1;i++)this._segments.push(new v(this._nodes[n+i],this._nodes[n+i+1]))}for(let s=0;s<t;s++)for(let n=0;n<e-1;n++){const i=n*t+s,o=(n+1)*t+s;this._segments.push(new v(this._nodes[i],this._nodes[o]))}}}get length(){return this._shapes.length}get nodes(){return this._nodes}get pathSegments(){return this._segments}get shapes(){return new M(this._shapes)}color(t){return this.shapes.color(t),this}trace(){this._traced=!0;for(const t of this._shapes)t.ephemeral=!1;return this}clone(t,e=0,s=0){return this._ephemeral=!0,new z(this,{count:t,offsetX:e,offsetY:s})}spread(t,e){const s=new c(t,e);for(let n=0;n<this._shapes.length;n++)if(this._shapes[n].translate(s.multiply(n)),this._nodes[n]){const i=this._shapes[n].centroid();this._nodes[n]=new x(i.x,i.y)}return this._segments=[],this._buildPathSegments(),this}every(t,e=0){const s=[];for(let n=e;n<this._shapes.length;n+=t)s.push(this._shapes[n]);return new M(s)}slice(t,e){const s=this._shapes.slice(t,e);return new M(s)}spreadPolar(t,e){let s=0,n=360;e!==void 0&&(typeof e=="number"?n=e:(s=e[0],n=e[1]));const i=n-s,o=this._shapes.length,r=i===360?i/o:i/Math.max(1,o-1);for(let h=0;h<o;h++){const u=(s+r*h)*Math.PI/180,d=Math.cos(u)*t,a=Math.sin(u)*t;this._shapes[h].moveTo(new c(d,a)),this._nodes[h]&&(this._nodes[h]=new x(d,a))}return this._segments=[],this._buildPathSegments(),this}resolveValue(t){return typeof t=="function"&&"current"in t?t():t}scale(t,e){if(e===void 0)this.shapes.scale(t);else for(const s of this._shapes){const n=s.centroid(),i=typeof t=="function"?t():t,o=typeof e=="function"?e():e;for(const r of s.vertices){const h=n.x+(r.position.x-n.x)*i,l=n.y+(r.position.y-n.y)*o;r.position=new c(h,l)}}return this}scaleX(t){return this.shapes.scaleX(t),this}scaleY(t){return this.shapes.scaleY(t),this}rotate(t){return this.shapes.rotate(t),this}translate(t,e){return this.shapes.translate(t,e),this}x(t){return this.shapes.x(t),this}y(t){return this.shapes.y(t),this}getNodes(){return this._nodes}filterByMask(t){this._shapes=this._shapes.filter(e=>t.containsPoint(e.centroid())),this._nodes=this._nodes.filter(e=>t.containsPoint(e.position)),this._segments=this.filterEdgesByMask(this._segments,t)}scaleGeometry(t){for(const e of this._shapes)e.scale(t);for(let e=0;e<this._shapes.length;e++){const s=this._shapes[e].centroid();this._nodes[e]=new x(s.x,s.y)}}rotateGeometry(t){for(const e of this._shapes)e.rotate(t)}stampGeometry(t,e){if(this._ephemeral)return;const s=e??{},n=e??I.line;t.beginGroup("clone-shapes");for(const i of this._shapes)i.ephemeral||t.addShape(i,s);if(t.endGroup(),this._traced&&this._segments.length>0){t.beginGroup("clone-path");for(const i of this._segments){const o=`M ${i.start.x} ${i.start.y} L ${i.end.x} ${i.end.y}`;t.addPath(o,n)}t.endGroup()}}getGeometryRenderGroups(){if(this._ephemeral)return[];const t=this._shapes.filter(s=>!s.ephemeral).map(s=>({shape:s,style:I.shape})),e=[];if(this._traced&&this._segments.length>0){const s=new S(this._segments,"ccw");s.open=!0,e.push({shape:s,style:I.line})}return[{name:"clone-shapes",items:t,defaultStyle:I.shape},{name:"clone-path",items:e,defaultStyle:I.line}]}getGeometryBounds(){let t=1/0,e=1/0,s=-1/0,n=-1/0;for(const i of this._shapes){const o=i.boundingBox();t=Math.min(t,o.min.x),e=Math.min(e,o.min.y),s=Math.max(s,o.max.x),n=Math.max(n,o.max.y)}return{minX:t,minY:e,maxX:s,maxY:n}}getSourceForSelection(){return this._shapes}}class V{constructor(t){this._items=t}get length(){return this._items.length}every(t,e=0){if(t<1)return this.createNew([]);const s=[];for(let n=e;n<this._items.length;n+=t)s.push(this._items[n]);return this.createNew(s)}at(...t){const e=[];for(const s of t)s>=0&&s<this._items.length&&e.push(this._items[s]);return this.createNew(e)}}const E=class E{constructor(t){this._shape=t}get shape(){return this._shape}get vertices(){return this._shape.vertices}get segments(){return this._shape.segments}get center(){return this._shape.centroid()}get centroid(){return this._shape.centroid()}get winding(){return this._shape.winding}get length(){let t=0;for(const e of this._shape.segments)t+=e.length();return t}get points(){return new N(this._shape,this._shape.vertices)}get lines(){return new X(this._shape,this._shape.segments)}clone(t=1,e=0,s=0){return this._shape.ephemeral=!0,new z(this._shape,{count:t,offsetX:e,offsetY:s})}scale(t,e){if(e===void 0)this._shape.scale(t);else{const s=this._shape.centroid();for(const n of this._shape.vertices){const i=s.x+(n.position.x-s.x)*t,o=s.y+(n.position.y-s.y)*e;n.position=new c(i,o)}}return this}scaleX(t){const e=this._shape.centroid();for(const s of this._shape.vertices){const n=e.x+(s.position.x-e.x)*t;s.position=new c(n,s.position.y)}return this}scaleY(t){const e=this._shape.centroid();for(const s of this._shape.vertices){const n=e.y+(s.position.y-e.y)*t;s.position=new c(s.position.x,n)}return this}rotate(t){return this._shape.rotate(t*Math.PI/180),this}rotateRad(t){return this._shape.rotate(t),this}moveTo(t,e){return typeof t=="number"?this._shape.moveTo(new c(t,e)):this._shape.moveTo(t),this}translate(t,e){return this._shape.translate(new c(t,e)),this}offset(t,e=0,s=4,n=!1){if(e>0){const o=[];n&&o.push(this._shape);let r=this._shape;for(let h=0;h<e;h++){const l=new E(r).offsetShape(t,s);o.push(l.shape),r=l.shape}return new M(o)}const i=this.offsetShape(t,s);return this._shape.segments=i.shape.segments,this._shape.winding=i.shape.winding,this._shape.connectSegments(),this}expand(t,e=0,s=4,n=!1){return this.offset(Math.abs(t),e,s,n)}inset(t,e=0,s=4){return this.offset(-Math.abs(t),e,s)}x(t){const e=this._shape.centroid(),s=t-e.x;return this._shape.translate(new c(s,0)),this}y(t){const e=this._shape.centroid(),s=t-e.y;return this._shape.translate(new c(0,s)),this}xy(t,e){const s=this._shape.centroid(),n=t-s.x,i=e-s.y;return this._shape.translate(new c(n,i)),this}reverse(){return this._shape.reverse(),this}bbox(){const t=this._shape.boundingBox(),e=S.fromPoints([t.min,new c(t.max.x,t.min.y),t.max,new c(t.min.x,t.max.y)]);return e.ephemeral=!0,new q(e,t.width,t.height)}centerPoint(){return this._shape.centroid()}trace(){return this._shape.ephemeral=!1,this}ephemeral(){return this._shape.ephemeral=!0,this}color(t){return this._shape.color=t,this}stamp(t,e=0,s=0,n={}){if(this._shape.ephemeral)return;const i=this._shape.clone();(e!==0||s!==0)&&i.translate(new c(e,s)),t.addShape(i,n)}explode(){this._shape.ephemeral=!0;const t=[];for(const e of this._shape.segments){const s=new x(e.start.position.x,e.start.position.y),n=new x(e.end.position.x,e.end.position.y);t.push(new v(s,n))}return new X(this._shape,t)}collapse(){return this._shape.ephemeral=!0,new j(this._shape.centroid(),this._shape)}offsetShape(t,e=4){const s=[],n=this._shape.vertices,i=this._shape.segments,o=n.length;for(let r=0;r<o;r++){const h=n[r],l=i[(r-1+o)%o],u=i[r],a=h.normal.multiply(t),f=l.start.position.add(l.normal.multiply(t)),p=l.end.position.add(l.normal.multiply(t)),g=u.start.position.add(u.normal.multiply(t)),_=u.end.position.add(u.normal.multiply(t)),m=this.lineIntersection(f,p,g,_);if(m){const w=m.subtract(h.position).length(),k=Math.abs(t)*e;w>k?(s.push(p),s.push(g)):s.push(m)}else s.push(h.position.add(a))}if(s.length>=3){const r=S.fromPoints(s,this._shape.winding);return new E(r)}return new E(this._shape.clone())}lineIntersection(t,e,s,n){const i=e.subtract(t),o=n.subtract(s),r=i.x*o.y-i.y*o.x;if(Math.abs(r)<1e-10)return null;const h=((s.x-t.x)*o.y-(s.y-t.y)*o.x)/r;return new c(t.x+h*i.x,t.y+h*i.y)}};E.globalCollector=null;let b=E;class N extends V{constructor(t,e){super(e),this._shape=t}get vertices(){return this._items}createNew(t){return new N(this._shape,t)}expand(t){for(const e of this._items)e.moveAlongNormal(t);for(const e of this._shape.segments)e.invalidateNormal();return new b(this._shape)}inset(t){return this.expand(-t)}move(t,e){const s=new c(t,e);for(const n of this._items)n.position=n.position.add(s);return this}midPoint(){if(this._items.length===0)return c.zero();let t=c.zero();for(const e of this._items)t=t.add(e.position);return t.divide(this._items.length)}bbox(){if(this._items.length===0)return{min:c.zero(),max:c.zero(),width:0,height:0,center:c.zero()};let t=1/0,e=1/0,s=-1/0,n=-1/0;for(const r of this._items)t=Math.min(t,r.x),e=Math.min(e,r.y),s=Math.max(s,r.x),n=Math.max(n,r.y);const i=new c(t,e),o=new c(s,n);return{min:i,max:o,width:s-t,height:n-e,center:i.lerp(o,.5)}}expandToCircles(t,e=32){const s=[];for(const n of this._items){const i=S.regularPolygon(e,t,n.position);s.push(i)}return new M(s)}raycast(t,e){const s=[],n=this._shape.centroid();for(const i of this._items){let o;if(typeof e=="number")o=e*Math.PI/180;else{const h=i.normal;if(h.length()>.001)o=Math.atan2(h.y,h.x),e==="inward"&&(o+=Math.PI);else{const l=n.subtract(i.position).normalize();o=Math.atan2(l.y,l.x),e==="outward"&&(o+=Math.PI)}}const r=new c(i.position.x+Math.cos(o)*t,i.position.y+Math.sin(o)*t);s.push(new x(r.x,r.y))}return new N(this._shape,s)}}class X extends V{constructor(t,e){super(e),this._shape=t}get segments(){return this._items}createNew(t){return new X(this._shape,t)}extrude(t){if(this._items.length===0)return new b(this._shape);const e=new Set(this._items),s=[],n=this._shape.segments;if(n.length===0)return new b(this._shape);for(let i=0;i<n.length;i++){const o=n[i],r=e.has(o);if(s.push(o.start.position),r){const h=o.normal.multiply(t);s.push(o.start.position.add(h)),s.push(o.end.position.add(h))}}if(s.length>=3){const i=s.filter((r,h,l)=>h===0?!0:!r.equals(l[h-1]));if(i.length>1&&i[0].equals(i[i.length-1])&&i.pop(),i.length<3)return new b(this._shape);const o=S.fromPoints(i,this._shape.winding);o.ephemeral=this._shape.ephemeral,this._shape.segments=o.segments,this._shape.winding=o.winding,this._shape.connectSegments()}return new b(this._shape)}divide(t){const e=[];for(const s of this._items)for(let n=1;n<t;n++){const i=n/t,o=s.pointAt(i);e.push(new x(o.x,o.y))}return new N(this._shape,e)}midPoint(){if(this._items.length===0)return c.zero();let t=c.zero();for(const e of this._items)t=t.add(e.midpoint());return t.divide(this._items.length)}collapse(){const t=[];for(const e of this._items){const s=e.midpoint();t.push(new x(s.x,s.y))}return new N(this._shape,t)}stamp(t,e=0,s=0,n={}){const i={...I.line,...n};for(const o of this._items){const r=o.start.position,h=o.end.position,l=`M ${r.x+e} ${r.y+s} L ${h.x+e} ${h.y+s}`;t.addPath(l,i)}}expandToRect(t){const e=[];for(const s of this._items){const n=s.start.position,i=s.end.position,o=s.normal.multiply(t),r=S.fromPoints([n.subtract(o),i.subtract(o),i.add(o),n.add(o)]);e.push(r)}return new M(e)}}class M extends V{constructor(t){super(t)}get shapes(){return this._items}createNew(t){return new M(t)}resolveValue(t){return typeof t=="function"&&"current"in t?t():t}slice(t,e){return new M(this._items.slice(t,e))}spread(t,e){const s=new c(t,e);for(let n=0;n<this._items.length;n++)this._items[n].translate(s.multiply(n));return this}clone(t,e=0,s=0){const n=new c(e,s),i=[...this._items];for(let o=1;o<=t;o++)for(const r of this._items){const h=r.clone();h.translate(n.multiply(o)),i.push(h)}return new M(i)}get points(){const t=[];for(const s of this._items)t.push(...s.vertices);const e=this._items[0]??S.fromPoints([c.zero(),new c(1,0),new c(0,1)]);return new N(e,t)}get lines(){const t=[];for(const s of this._items)t.push(...s.segments);const e=this._items[0]??S.fromPoints([c.zero(),new c(1,0),new c(0,1)]);return new X(e,t)}trace(){for(const t of this._items)t.ephemeral=!1;return this}scale(t){for(const e of this._items)e.scale(this.resolveValue(t));return this}scaleX(t){for(const e of this._items)new b(e).scaleX(this.resolveValue(t));return this}scaleY(t){for(const e of this._items)new b(e).scaleY(this.resolveValue(t));return this}rotate(t){for(const e of this._items){const s=this.resolveValue(t);e.rotate(s*Math.PI/180)}return this}translate(t,e){for(const s of this._items){const n=this.resolveValue(t),i=this.resolveValue(e);s.translate(new c(n,i))}return this}offset(t,e=0,s=4,n=!1){if(e>0){const i=[];for(const o of this._items){n&&i.push(o);let r=o;for(let h=0;h<e;h++){const u=new b(r).offsetShape(t,s);i.push(u.shape),r=u.shape}}return new M(i)}for(let i=0;i<this._items.length;i++){const o=this._items[i],h=new b(o).offsetShape(t,s);o.segments=h.shape.segments,o.winding=h.shape.winding,o.connectSegments()}return this}expand(t,e=0,s=4,n=!1){return this.offset(Math.abs(t),e,s,n)}inset(t,e=0,s=4){return this.offset(-Math.abs(t),e,s)}color(t){if(t instanceof T)for(const e of this._items)e.color=t.next();else if(typeof t=="function"&&"current"in t)for(const e of this._items){const s=t();e.color=String(s)}else for(const e of this._items)e.color=t;return this}moveTo(t,e){const s=this.getBounds(),n=new c((s.minX+s.maxX)/2,(s.minY+s.maxY)/2),i=new c(t,e).subtract(n);return this.translate(i.x,i.y)}x(t){if(typeof t=="function"&&"current"in t)for(const e of this._items){const s=this.resolveValue(t),n=e.centroid().x;e.translate(new c(s-n,0))}else{const e=this.getBounds(),s=(e.minX+e.maxX)/2;this.translate(t-s,0)}return this}y(t){if(typeof t=="function"&&"current"in t)for(const e of this._items){const s=this.resolveValue(t),n=e.centroid().y;e.translate(new c(0,s-n))}else{const e=this.getBounds(),s=(e.minY+e.maxY)/2;this.translate(0,t-s)}return this}xy(t,e){return this.moveTo(t,e)}getBounds(){let t=1/0,e=1/0,s=-1/0,n=-1/0;for(const i of this._items)for(const o of i.vertices)t=Math.min(t,o.x),e=Math.min(e,o.y),s=Math.max(s,o.x),n=Math.max(n,o.y);return{minX:t,minY:e,maxX:s,maxY:n}}get vertices(){const t=[];for(const e of this._items)t.push(...e.vertices);return t}get segments(){const t=[];for(const e of this._items)t.push(...e.segments);return t}get center(){const t=this.getBounds();return new c((t.minX+t.maxX)/2,(t.minY+t.maxY)/2)}stamp(t,e=0,s=0,n={}){for(const i of this._items){if(i.ephemeral)continue;const o=i.clone();(e!==0||s!==0)&&o.translate(new c(e,s)),t.addShape(o,n)}}spreadPolar(t,e){let s=0,n=360;e!==void 0&&(typeof e=="number"?n=e:(s=e[0],n=e[1]));const i=n-s,o=this._items.length,r=i===360?i/o:i/Math.max(1,o-1);for(let h=0;h<o;h++){const u=(s+r*h)*Math.PI/180,d=Math.cos(u)*t,a=Math.sin(u)*t;this._items[h].moveTo(new c(d,a))}return this}}class K extends b{constructor(){super(S.regularPolygon(32,10)),this._radius=10,this._segments=32,this._center=c.zero()}radius(t){return this._radius=t,this.rebuild(),this}numSegments(t){return this._segments=Math.max(3,t),this.rebuild(),this}setCenter(t,e){return this._center=new c(t,e),this.rebuild(),this}rebuild(){this._shape=S.regularPolygon(this._segments,this._radius,this._center)}}class q extends b{constructor(t,e=10,s=10){super(t??q.createRect(e,s,c.zero())),this._center=c.zero(),this._width=e,this._height=s}get w(){return this._width}get h(){return this._height}width(t){return this._width=t,this.rebuild(),this}height(t){return this._height=t,this.rebuild(),this}wh(t,e){return this._width=t,this._height=e,this.rebuild(),this}size(t){return this.wh(t,t)}setCenter(t,e){return this._center=new c(t,e),this.rebuild(),this}rebuild(){this._shape=q.createRect(this._width,this._height,this._center)}static createRect(t,e,s){const n=t/2,i=e/2;return S.fromPoints([new c(s.x-n,s.y-i),new c(s.x+n,s.y-i),new c(s.x+n,s.y+i),new c(s.x-n,s.y+i)])}}class U extends q{constructor(t=10){super(void 0,t,t)}size(t){return this.wh(t,t)}}class Q extends b{constructor(){super(S.regularPolygon(6,10,c.zero(),Math.PI/6)),this._radius=10,this._center=c.zero()}radius(t){return this._radius=t,this.rebuild(),this}setCenter(t,e){return this._center=new c(t,e),this.rebuild(),this}rebuild(){this._shape=S.regularPolygon(6,this._radius,this._center,Math.PI/6)}}class J extends b{constructor(){super(S.regularPolygon(3,10,c.zero(),-Math.PI/2)),this._radius=10,this._center=c.zero()}radius(t){return this._radius=t,this.rebuild(),this}setCenter(t,e){return this._center=new c(t,e),this.rebuild(),this}rebuild(){this._shape=S.regularPolygon(3,this._radius,this._center,-Math.PI/2)}}const ht={circle(){return new K},rect(){return new q},square(){return new U},hexagon(){return new Q},triangle(){return new J}};class st extends B{constructor(){super(...arguments),this._nodes=[],this._edges=[]}filterByMask(t){this._nodes=this._nodes.filter(e=>t.containsPoint(e)),this._edges=this._edges.filter(e=>t.containsPoint(e.midpoint()))}scaleGeometry(t){this._nodes=this._nodes.map(e=>new c(e.x*t,e.y*t)),this._edges=this._edges.map(e=>{const s=new x(e.start.x*t,e.start.y*t),n=new x(e.end.x*t,e.end.y*t);return new v(s,n)}),this._edges.length>0&&new S(this._edges).connectSegments()}rotateGeometry(t){const e=Math.cos(t),s=Math.sin(t);this._nodes=this._nodes.map(n=>{const i=n.x*e-n.y*s,o=n.x*s+n.y*e;return new c(i,o)}),this._edges=this._edges.map(n=>{const i=n.start.x*e-n.start.y*s,o=n.start.x*s+n.start.y*e,r=n.end.x*e-n.end.y*s,h=n.end.x*s+n.end.y*e;return new v(new x(i,o),new x(r,h))})}stampGeometry(t,e){const s=e??I.connection;if(this._traced&&this._edges.length>0){t.beginGroup(this.getEdgeGroupName());for(const n of this._edges){const i=`M ${n.start.x} ${n.start.y} L ${n.end.x} ${n.end.y}`;t.addPath(i,s)}t.endGroup()}}getGeometryRenderGroups(){if(!this._traced||this._edges.length===0)return[];const t=new S(this._edges,"ccw");return t.open=!0,[{name:this.getEdgeGroupName(),items:[{shape:t,style:I.connection}],defaultStyle:I.connection}]}getGeometryBounds(){let t=1/0,e=1/0,s=-1/0,n=-1/0;for(const i of this._nodes)t=Math.min(t,i.x),e=Math.min(e,i.y),s=Math.max(s,i.x),n=Math.max(n,i.y);return{minX:t,minY:e,maxX:s,maxY:n}}getSourceForSelection(){return[]}}class D extends st{constructor(t={}){var s,n;super(),this._gridNodes=[],this._type=t.type??"square",t.rows!==void 0||t.cols!==void 0?(this._rows=t.rows??3,this._cols=t.cols??3):t.count!==void 0?typeof t.count=="number"?(this._rows=t.count,this._cols=t.count):(this._rows=t.count[0],this._cols=t.count[1]):(this._rows=3,this._cols=3),this._orientation=t.orientation??"pointy";const e=t.spacing??t.size??40;typeof e=="number"?(this._spacingX=e,this._spacingY=e):Array.isArray(e)?(this._spacingX=e[0],this._spacingY=e[1]):(this._spacingX=e.x,this._spacingY=e.y),this._offsetX=((s=t.offset)==null?void 0:s[0])??0,this._offsetY=((n=t.offset)==null?void 0:n[1])??0,this.buildGrid(),this._buildGridEdges()}static create(t){return new D(t)}buildGrid(){switch(this._type){case"hexagonal":this.buildHexGrid();break;case"triangular":this.buildTriangularGrid();break;default:this.buildSquareGrid()}}buildSquareGrid(){for(let t=0;t<=this._rows;t++)for(let e=0;e<=this._cols;e++){const s=this._offsetX+e*this._spacingX,n=this._offsetY+t*this._spacingY;this._gridNodes.push({x:s,y:n,row:t,col:e}),this._nodes.push(new c(s,n))}}buildHexGrid(){const t=this._spacingX,e=this._orientation==="pointy"?t*Math.sqrt(3):t*2,s=this._orientation==="pointy"?t*2:t*Math.sqrt(3),n=this._orientation==="pointy"?s*.75:s,i=this._orientation==="pointy"?e:e*.75,o=new Map,r=(l,u)=>`${l.toFixed(6)},${u.toFixed(6)}`;let h=0;for(let l=0;l<this._rows;l++)for(let u=0;u<this._cols;u++){let d,a;if(this._orientation==="pointy"){const p=l%2*e/2;d=this._offsetX+u*i+p,a=this._offsetY+l*n}else{const p=u%2*s/2;d=this._offsetX+u*i,a=this._offsetY+l*n+p}const f=this._orientation==="pointy"?Math.PI/6:0;for(let p=0;p<6;p++){const g=f+p*Math.PI/3,_=d+t*Math.cos(g),m=a+t*Math.sin(g),w=r(_,m);o.has(w)||(o.set(w,{x:_,y:m,row:h,col:0}),h++)}}this._gridNodes=Array.from(o.values()),this._nodes=this._gridNodes.map(l=>new c(l.x,l.y))}buildTriangularGrid(){const t=this._spacingX,e=t*Math.sqrt(3)/2,s=new Map,n=(o,r)=>`${o.toFixed(6)},${r.toFixed(6)}`;let i=0;for(let o=0;o<this._rows;o++)for(let r=0;r<this._cols;r++){const h=this._offsetX+r*t/2,l=this._offsetY+o*e,u=(o+r)%2===0;let d;u?d=[new c(h,l+e),new c(h+t,l+e),new c(h+t/2,l)]:d=[new c(h,l),new c(h+t,l),new c(h+t/2,l+e)];for(const a of d){const f=n(a.x,a.y);s.has(f)||(s.set(f,{x:a.x,y:a.y,row:i,col:0}),i++)}}this._gridNodes=Array.from(s.values()),this._nodes=this._gridNodes.map(o=>new c(o.x,o.y))}_buildGridEdges(){if(this._edges=[],this._type==="square"){for(let t=0;t<=this._rows;t++){const e=this._offsetY+t*this._spacingY,s=this._offsetX,n=this._offsetX+this._cols*this._spacingX;this._edges.push(new v(new x(s,e),new x(n,e)))}for(let t=0;t<=this._cols;t++){const e=this._offsetX+t*this._spacingX,s=this._offsetY,n=this._offsetY+this._rows*this._spacingY;this._edges.push(new v(new x(e,s),new x(e,n)))}}else{const t=Math.max(this._spacingX,this._spacingY)*1.1,e=new Map,s=(n,i)=>{const o=n.x.toFixed(6),r=n.y.toFixed(6),h=i.x.toFixed(6),l=i.y.toFixed(6);return o<h||o===h&&r<l?`${o},${r}-${h},${l}`:`${h},${l}-${o},${r}`};for(let n=0;n<this._nodes.length;n++){const i=this._nodes[n];for(let o=n+1;o<this._nodes.length;o++){const r=this._nodes[o],h=r.x-i.x,l=r.y-i.y;if(Math.sqrt(h*h+l*l)<t){const d=s(i,r);e.has(d)||e.set(d,new v(new x(i.x,i.y),new x(r.x,r.y)))}}}this._edges=Array.from(e.values())}}get nodes(){const t=this._nodes.map(e=>new x(e.x,e.y));return new W(this,t,this._gridNodes)}getEdgeGroupName(){return"grid-edges"}getNodes(){return this._nodes.map(t=>new x(t.x,t.y))}filterByMask(t){this._gridNodes=this._gridNodes.filter(e=>t.containsPoint(new c(e.x,e.y))),super.filterByMask(t)}get rows(){const t=[],e=S.regularPolygon(3,1);if(this._type==="square")for(let s=0;s<=this._rows;s++){const n=this._offsetY+s*this._spacingY,i=this._offsetX,o=this._offsetX+this._cols*this._spacingX;t.push(new v(new x(i,n),new x(o,n)))}else for(const s of this._edges){const n=Math.abs(s.end.x-s.start.x),i=Math.abs(s.end.y-s.start.y);n>=i&&t.push(s)}return new X(e,t)}get columns(){const t=[],e=S.regularPolygon(3,1);if(this._type==="square")for(let s=0;s<=this._cols;s++){const n=this._offsetX+s*this._spacingX,i=this._offsetY,o=this._offsetY+this._rows*this._spacingY;t.push(new v(new x(n,i),new x(n,o)))}else for(const s of this._edges){const n=Math.abs(s.end.x-s.start.x);Math.abs(s.end.y-s.start.y)>n&&t.push(s)}return new X(e,t)}addPlacement(t,e,s){this._placements.push({position:t,shape:e,style:s})}color(t){return this.shapes.color(t),this}}class W extends N{constructor(t,e,s){super(S.regularPolygon(3,1),e),this._grid=t,this._gridNodes=s}place(t,e){for(const s of this._items){const n=t.shape.clone();n.moveTo(s.position),this._grid.addPlacement(s.position,n,e)}return this}every(t,e=0){const s=[],n=[];for(let i=e;i<this._items.length;i+=t)s.push(this._items[i]),n.push(this._gridNodes[i]);return new W(this._grid,s,n)}at(...t){const e=[],s=[];for(const n of t)n>=0&&n<this._items.length&&(e.push(this._items[n]),s.push(this._gridNodes[n]));return new W(this._grid,e,s)}color(t){const e=new Set(this._items.map(i=>`${i.position.x},${i.position.y}`)),n=this._grid._placements.filter(i=>e.has(`${i.position.x},${i.position.y}`));if(typeof t=="function"&&"current"in t)for(const i of n){const o=t();i.shape.color=String(o)}else for(const i of n)i.shape.color=t;return this}}class A extends st{constructor(t={}){super();const e=t.pattern??"penrose",s=t.bounds??{width:400,height:400};switch(this._bounds=s,this._pattern=e,e){case"trihexagonal":this.buildTrihexagonal({...t,pattern:e,bounds:s});break;case"penrose":this.buildPenrose({...t,pattern:e,bounds:s});break;case"custom":this.buildCustom({...t,pattern:e,bounds:s});break}this._edges.length===0&&this._extractUniqueEdges()}static create(t){return new A(t)}buildTrihexagonal(t){const e=t.spacing??30,s=e/2,n=s,i=e*Math.sqrt(3),o=e*1.5,r=Math.ceil(this._bounds.width/i)+1,h=Math.ceil(this._bounds.height/o)+1,l=new Map,u=(d,a)=>`${d.toFixed(6)},${a.toFixed(6)}`;for(let d=0;d<h;d++)for(let a=0;a<r;a++){const f=d%2*i/2,p=a*i+f,g=d*o;if(p<-e||p>this._bounds.width+e||g<-e||g>this._bounds.height+e)continue;const m=S.regularPolygon(6,s,new c(p,g),Math.PI/6).vertices;for(const w of m){const k=u(w.position.x,w.position.y);l.has(k)||l.set(k,new c(w.position.x,w.position.y))}for(let w=0;w<6;w++){const k=m[w].position,G=m[(w+1)%6].position,$=k.add(G).divide(2).subtract(new c(p,g)).normalize(),C=k.add(G).divide(2).add($.multiply(n*.866)),ot=u(C.x,C.y);l.has(ot)||l.set(ot,new c(C.x,C.y))}}this._nodes=Array.from(l.values())}buildPenrose(t){const e=t.iterations??4,s=(1+Math.sqrt(5))/2,n=this._bounds.width/2,i=this._bounds.height/2,o=Math.max(this._bounds.width,this._bounds.height)*.6;let r=[];for(let a=0;a<10;a++){const f=(2*a-1)*Math.PI/10,p=(2*a+1)*Math.PI/10;let g=new c(n+Math.cos(f)*o,i+Math.sin(f)*o),_=new c(n+Math.cos(p)*o,i+Math.sin(p)*o);a%2===0&&([g,_]=[_,g]),r.push({color:0,a:new c(n,i),b:g,c:_})}for(let a=0;a<e;a++){const f=[];for(const p of r)if(p.color===0){const g=p.a.add(p.b.subtract(p.a).divide(s));f.push({color:0,a:p.c,b:g,c:p.b}),f.push({color:1,a:g,b:p.c,c:p.a})}else{const g=p.b.add(p.a.subtract(p.b).divide(s)),_=p.b.add(p.c.subtract(p.b).divide(s));f.push({color:1,a:_,b:p.c,c:p.a}),f.push({color:1,a:g,b:_,c:p.b}),f.push({color:0,a:_,b:g,c:p.a})}r=f}const h=new Map,l=new Map,u=(a,f)=>`${a.toFixed(6)},${f.toFixed(6)}`,d=(a,f)=>{const p=a.x.toFixed(6),g=a.y.toFixed(6),_=f.x.toFixed(6),m=f.y.toFixed(6);return p<_||p===_&&g<m?`${p},${g}-${_},${m}`:`${_},${m}-${p},${g}`};for(const a of r){const f=a.a.add(a.b).add(a.c).divide(3);if(f.x<0||f.x>this._bounds.width||f.y<0||f.y>this._bounds.height)continue;for(const g of[a.a,a.b,a.c]){const _=u(g.x,g.y);h.has(_)||h.set(_,new c(g.x,g.y))}const p=[[a.a,a.b],[a.b,a.c],[a.c,a.a]];for(const[g,_]of p){const m=d(g,_);l.has(m)||l.set(m,new v(new x(g.x,g.y),new x(_.x,_.y)))}}this._nodes=Array.from(h.values()),this._edges=Array.from(l.values())}buildCustom(t){if(!t.unit)throw new Error("Custom tessellation requires a unit shape");const e=t.spacing??40,s=t.arrangement??"square",n=t.unit.shape,i=new Map,o=(l,u)=>`${l.toFixed(6)},${u.toFixed(6)}`,r=Math.ceil(this._bounds.width/e)+1,h=Math.ceil(this._bounds.height/e)+1;for(let l=0;l<h;l++)for(let u=0;u<r;u++){let d,a;if(s==="hexagonal"){const p=e*Math.sqrt(3),g=l%2*p/2;d=u*p+g,a=l*e*.75}else if(s==="triangular"){const p=e*Math.sqrt(3)/2;d=u*e/2,a=l*p}else d=u*e,a=l*e;if(d>this._bounds.width+e||a>this._bounds.height+e)continue;const f=n.clone();f.moveTo(new c(d,a));for(const p of f.vertices){const g=o(p.position.x,p.position.y);i.has(g)||i.set(g,new c(p.position.x,p.position.y))}}this._nodes=Array.from(i.values())}_extractUniqueEdges(){if(this._nodes.length===0){this._edges=[];return}let t=0,e=0;const s=Math.min(10,this._nodes.length);for(let r=0;r<s&&r<this._nodes.length;r++){const h=this._nodes[r];let l=1/0;for(let u=0;u<this._nodes.length;u++){if(r===u)continue;const d=this._nodes[u],a=d.x-h.x,f=d.y-h.y,p=Math.sqrt(a*a+f*f);p<l&&(l=p)}l!==1/0&&(t+=l,e++)}const i=(e>0?t/e:50)*1.5,o=new Map;for(let r=0;r<this._nodes.length;r++){const h=this._nodes[r];for(let l=r+1;l<this._nodes.length;l++){const u=this._nodes[l],d=u.x-h.x,a=u.y-h.y;if(Math.sqrt(d*d+a*a)<i){const p=new v(new x(h.x,h.y),new x(u.x,u.y)),g=this._edgeKey(p);o.has(g)||o.set(g,p)}}}this._edges=Array.from(o.values())}_edgeKey(t){const e=t.start.x,s=t.start.y,n=t.end.x,i=t.end.y;let o,r,h,l;return e<n||e===n&&s<i?(o=e,r=s,h=n,l=i):(o=n,r=i,h=e,l=s),`${o.toFixed(6)},${r.toFixed(6)}-${h.toFixed(6)},${l.toFixed(6)}`}get nodes(){const t=this._nodes.map(s=>new x(s.x,s.y)),e=S.regularPolygon(3,1);return new N(e,t)}get edges(){const t=S.regularPolygon(3,1);return new X(t,this._edges)}getEdgeGroupName(){return"tessellation-edges"}getNodes(){return this._nodes.map(t=>new x(t.x,t.y))}}class R extends B{constructor(t,e={}){super(),this._nodes=[],this._edges=[],this._centerNode=null,t instanceof b?(t.shape.ephemeral=!0,this._sourceShape=t.shape.clone()):(t.ephemeral=!0,this._sourceShape=t.clone()),this._sourceShape.ephemeral=!0;const{includeCenter:s=!1,subdivide:n}=e;if(n&&n>1)for(const i of this._sourceShape.segments){this._nodes.push(new x(i.start.x,i.start.y));for(let o=1;o<n;o++){const r=o/n,h=i.start.position.lerp(i.end.position,r);this._nodes.push(new x(h.x,h.y))}}else for(const i of this._sourceShape.vertices)this._nodes.push(new x(i.x,i.y));if(s){const i=this._sourceShape.centroid();this._centerNode=new x(i.x,i.y)}this.buildEdges(n)}buildEdges(t){const e=this._nodes.length;if(!(e<2))for(let s=0;s<e;s++){const n=this._nodes[s],i=this._nodes[(s+1)%e];this._edges.push(new v(n,i))}}static create(t,e={}){return new R(t,e)}trace(){return this._traced=!0,this._sourceShape.ephemeral=!1,this}get nodes(){const t=this._centerNode?[...this._nodes,this._centerNode]:[...this._nodes];return new H(this,t)}get edges(){return new X(this._sourceShape,[...this._edges])}get center(){return this._centerNode?new j(this._centerNode.position,this._sourceShape):null}bbox(){return this._sourceShape.boundingBox()}addPlacement(t,e,s){this._placements.push({position:t,shape:e,style:s})}getNodes(){return this._centerNode?[...this._nodes,this._centerNode]:[...this._nodes]}filterByMask(t){this._nodes=this._nodes.filter(e=>t.containsPoint(e.position)),this._centerNode&&!t.containsPoint(this._centerNode.position)&&(this._centerNode=null),this._edges=this.filterEdgesByMask(this._edges,t)}scaleGeometry(t){this._sourceShape.scale(t)}rotateGeometry(t){this._sourceShape.rotate(t)}stampGeometry(t,e){const s=e??I.connection;this._traced&&!this._sourceShape.ephemeral&&(t.beginGroup("shape"),t.addShape(this._sourceShape,s),t.endGroup())}getGeometryRenderGroups(){const t=[];return this._traced&&!this._sourceShape.ephemeral&&t.push({shape:this._sourceShape}),[{name:"shape",items:t,defaultStyle:I.connection}]}getGeometryBounds(){const t=this._centerNode?[...this._nodes,this._centerNode]:this._nodes;return this.boundsFromPositions(t)}getSourceForSelection(){return[]}}class H extends N{constructor(t,e){super(S.regularPolygon(3,1),e),this._system=t}place(t,e){for(const s of this._items){const n=t.shape.clone();n.moveTo(s.position),this._system.addPlacement(s.position,n,e)}return this}every(t,e=0){const s=[];for(let n=e;n<this._items.length;n+=t)s.push(this._items[n]);return new H(this._system,s)}at(...t){const e=[];for(const s of t)s>=0&&s<this._items.length&&e.push(this._items[s]);return new H(this._system,e)}}class O extends B{constructor(t){super(),this._segments=[],this._nodes=[],this._endpoints=[],this._config={origin:[0,0],heading:0,...t};const e=this.applyRules(this._config.axiom,this._config.rules,this._config.iterations),{segments:s,nodes:n,endpoints:i}=this.interpretTurtle(e,this._config.angle,this._config.length,this._config.origin,this._config.heading);this._segments=s,this._nodes=n,this._endpoints=i,this._shape=new S(this._segments,"ccw"),this._shape.ephemeral=!0,this._shape.open=!0,this.segments=new X(this._shape,this._segments),this.nodes=new N(this._shape,this._nodes),this.endpoints=new N(this._shape,this._endpoints),this.path=new b(this._shape),this.path.ephemeral()}static create(t){return new O(t)}applyRules(t,e,s){let n=t;for(let i=0;i<s;i++){let o="";for(const r of n)o+=e[r]||r;n=o}return n}interpretTurtle(t,e,s,n,i){const o=[],r=[],h=[],l=[];let u=n[0],d=n[1],a=i*Math.PI/180;const f=e*Math.PI/180;r.push(new x(u,d));for(const _ of t)switch(_){case"F":case"G":{const m=u+Math.cos(a)*s,w=d+Math.sin(a)*s,k=new x(u,d),G=new x(m,w);o.push(new v(k,G)),r.push(G),u=m,d=w;break}case"f":{u+=Math.cos(a)*s,d+=Math.sin(a)*s,r.push(new x(u,d));break}case"+":a+=f;break;case"-":a-=f;break;case"|":a+=Math.PI;break;case"[":l.push({x:u,y:d,dir:a});break;case"]":if(h.push(new x(u,d)),l.length>0){const m=l.pop();u=m.x,d=m.y,a=m.dir}break}const p=s*.01,g=Math.sqrt(Math.pow(u-n[0],2)+Math.pow(d-n[1],2));if(g<p&&g>0&&o.length>0){const _=new x(u,d),m=new x(n[0],n[1]);o.push(new v(_,m)),r.push(m)}return h.push(new x(u,d)),{segments:o,nodes:r,endpoints:h}}trace(){return this._traced=!0,this._shape.ephemeral=!1,this}getNodes(){return this._nodes}filterByMask(t){this._nodes=this._nodes.filter(e=>t.containsPoint(e.position)),this._endpoints=this._endpoints.filter(e=>t.containsPoint(e.position)),this._segments=this.filterEdgesByMask(this._segments,t),this._shape.segments=this._segments,this.nodes=new N(this._shape,this._nodes),this.endpoints=new N(this._shape,this._endpoints),this.segments=new X(this._shape,this._segments),this.path=new b(this._shape)}scaleGeometry(t){this._shape.scale(t)}rotateGeometry(t){this._shape.rotate(t)}stampGeometry(t,e){const s=e??I.line;this._traced&&!this._shape.ephemeral&&(t.beginGroup("lsystem-path"),this.path.stamp(t,0,0,s),t.endGroup())}getGeometryRenderGroups(){const t=[];return this._traced&&!this._shape.ephemeral&&t.push({shape:this._shape,style:I.line}),[{name:"lsystem-path",items:t,defaultStyle:I.line}]}getGeometryBounds(){return this.boundsFromPositions(this._nodes)}getSourceForSelection(){return[]}}const nt={pinwheel:{name:"pinwheel",grid:2,cells:[[{type:"hst",rotation:90},{type:"hst",rotation:180}],[{type:"hst",rotation:0},{type:"hst",rotation:270}]]},brokenDishes:{name:"brokenDishes",grid:2,cells:[[{type:"hst",rotation:0},{type:"hst",rotation:270}],[{type:"hst",rotation:90},{type:"hst",rotation:180}]]},friendshipStar:{name:"friendshipStar",grid:3,cells:[[{type:"square",group:"light"},{type:"hst",rotation:180},{type:"square",group:"light"}],[{type:"hst",rotation:90},{type:"square",group:"dark"},{type:"hst",rotation:270}],[{type:"square",group:"light"},{type:"hst",rotation:0},{type:"square",group:"light"}]]},shooFly:{name:"shooFly",grid:3,cells:[[{type:"hst",rotation:180},{type:"square",group:"light"},{type:"hst",rotation:270}],[{type:"square",group:"light"},{type:"square",group:"dark"},{type:"square",group:"light"}],[{type:"hst",rotation:90},{type:"square",group:"light"},{type:"hst",rotation:0}]]},bowTie:{name:"bowTie",grid:2,cells:[[{type:"hst",rotation:0},{type:"hst",rotation:0}],[{type:"hst",rotation:180},{type:"hst",rotation:180}]]},dutchmansPuzzle:{name:"dutchmansPuzzle",grid:2,cells:[[{type:"flyingGeese",rotation:270},{type:"flyingGeese",rotation:0}],[{type:"flyingGeese",rotation:180},{type:"flyingGeese",rotation:90}]]},sawtoothStar:{name:"sawtoothStar",grid:3,cells:[[{type:"square",group:"light"},{type:"flyingGeese",rotation:270},{type:"square",group:"light"}],[{type:"flyingGeese",rotation:180},{type:"square",group:"dark"},{type:"flyingGeese",rotation:0}],[{type:"square",group:"light"},{type:"flyingGeese",rotation:90},{type:"square",group:"light"}]]}};class at{constructor(t,e){this._selectedIndices=[],this._system=t,this._placements=e}every(t,e=0){return this._selectedIndices=this._placements.filter((s,n)=>(n-e)%t===0).map(s=>s.index),this}slice(t,e){const s=this._placements.slice(t,e);return this._selectedIndices=s.map(n=>n.index),this}at(...t){return this._selectedIndices=t.filter(e=>e>=0&&e<this._placements.length),this}all(){return this._selectedIndices=[],this}placeBlock(t){Z(t);const e=this._selectedIndices.length>0?this._selectedIndices:this._placements.map(s=>s.index);for(const s of e)this._placements[s].blockName=t;return this._selectedIndices=[],this._system}}const it={pinwheel:"pinwheel",brokenDishes:"brokenDishes",friendshipStar:"friendshipStar",shooFly:"shooFly",bowTie:"bowTie",dutchmansPuzzle:"dutchmansPuzzle",sawtoothStar:"sawtoothStar",PW:"pinwheel",BD:"brokenDishes",FS:"friendshipStar",SF:"shooFly",BT:"bowTie",DP:"dutchmansPuzzle",SS:"sawtoothStar"};function Z(y){const t=it[y]||y,e=nt[t];if(!e){const s=Object.keys(it).join(", ");throw new Error(`Unknown block: "${y}". Available: ${s}`)}return e}class tt extends B{constructor(t){super(),this._quiltPlacements=[];const{gridSize:e,blockSize:s,defaultBlock:n="pinwheel"}=t;this._cols=e[0],this._rows=e[1],this._blockSize=s,this._defaultBlock=n;let i=0;for(let o=0;o<this._rows;o++)for(let r=0;r<this._cols;r++)this._quiltPlacements.push({x:r*s,y:o*s,row:o,col:r,index:i,blockName:void 0}),i++}get pattern(){return new at(this,this._quiltPlacements)}get shapes(){const e=[...this.getSourceForSelection(),...this._placements.map(s=>s.shape)];return new M(e)}get length(){return this._quiltPlacements.length}_buildBlock(t,e,s){const n=[],i=this._blockSize/t.grid;for(let o=0;o<t.grid;o++)for(let r=0;r<t.grid;r++){const h=e+r*i,l=s+o*i,u=t.cells[o][r];switch(u.type){case"square":n.push(this._createSquare(h,l,i,u.group));break;case"hst":n.push(...this._createHST(h,l,i,u.rotation));break;case"flyingGeese":n.push(...this._createFlyingGeese(h,l,i,u.rotation));break}}return n}_createSquare(t,e,s,n){const i=S.fromPoints([new c(t,e),new c(t+s,e),new c(t+s,e+s),new c(t,e+s)]);return i.group=n,i}_createHST(t,e,s,n){const i=[],o=new c(t,e),r=new c(t+s,e),h=new c(t,e+s),l=new c(t+s,e+s);let u,d;switch(n){case 0:u=[o,r,h],d=[r,l,h];break;case 90:u=[o,r,l],d=[o,l,h];break;case 180:u=[r,l,h],d=[o,r,h];break;case 270:u=[o,l,h],d=[o,r,l];break}const a=S.fromPoints(u);a.group="dark",i.push(a);const f=S.fromPoints(d);return f.group="light",i.push(f),i}_createFlyingGeese(t,e,s,n){const i=[],o=s/2,r=new c(t,e),h=new c(t+s,e),l=new c(t,e+s),u=new c(t+s,e+s),d=new c(t+o,e),a=new c(t+o,e+s),f=new c(t,e+o),p=new c(t+s,e+o);let g,_,m;switch(n){case 0:g=[r,p,l],_=[r,h,p],m=[p,u,l];break;case 90:g=[r,h,a],_=[r,a,l],m=[h,u,a];break;case 180:g=[f,h,u],_=[r,h,f],m=[f,u,l];break;case 270:g=[d,l,u],_=[r,d,l],m=[d,h,u];break}const w=S.fromPoints(g);w.group="dark",i.push(w);const k=S.fromPoints(_);k.group="light",i.push(k);const G=S.fromPoints(m);return G.group="light",i.push(G),i}getNodes(){return this._quiltPlacements.map(t=>new x(t.x+this._blockSize/2,t.y+this._blockSize/2))}filterByMask(t){this._quiltPlacements=this._quiltPlacements.filter(e=>{const s=e.x+this._blockSize/2,n=e.y+this._blockSize/2;return t.containsPoint(new c(s,n))}),this._quiltPlacements.forEach((e,s)=>e.index=s)}scaleGeometry(t){this._blockSize*=t,this._quiltPlacements.forEach(e=>{e.x*=t,e.y*=t})}rotateGeometry(t){const e=this._getCenter(),s=Math.cos(t),n=Math.sin(t);this._quiltPlacements.forEach(i=>{const o=i.x-e.x,r=i.y-e.y;i.x=e.x+(o*s-r*n),i.y=e.y+(o*n+r*s)})}stampGeometry(t,e){if(this._traced){t.beginGroup("quilt-blocks");for(const s of this._quiltPlacements){const n=s.blockName??this._defaultBlock,i=Z(n),o=this._buildBlock(i,s.x,s.y);for(const r of o){const h=r.group==="dark"?(e==null?void 0:e.fill)??I.shape.fill:"#ecf0f1";t.addShape(r,{...e,fill:h})}}t.endGroup()}}getGeometryRenderGroups(){if(!this._traced)return[];const t=[];for(const e of this._quiltPlacements){const s=e.blockName??this._defaultBlock,n=Z(s),i=this._buildBlock(n,e.x,e.y);t.push(...i.map(o=>({shape:o})))}return[{name:"quilt-blocks",items:t,defaultStyle:I.shape}]}getGeometryBounds(){if(this._quiltPlacements.length===0)return{minX:0,minY:0,maxX:0,maxY:0};let t=1/0,e=1/0,s=-1/0,n=-1/0;for(const i of this._quiltPlacements)t=Math.min(t,i.x),e=Math.min(e,i.y),s=Math.max(s,i.x+this._blockSize),n=Math.max(n,i.y+this._blockSize);return{minX:t,minY:e,maxX:s,maxY:n}}getSourceForSelection(){const t=[];for(const e of this._quiltPlacements){const s=e.blockName??this._defaultBlock,n=Z(s);t.push(...this._buildBlock(n,e.x,e.y))}return t}_getCenter(){const t=this.getBounds();return new c(t.minX+(t.maxX-t.minX)/2,t.minY+(t.maxY-t.minY)/2)}}var ct=Object.freeze({__proto__:null,CircleContext:K,CloneSystem:z,GridSystem:D,HexagonContext:Q,LSystem:O,LinesContext:X,Palette:T,PointsContext:N,QuiltSystem:tt,RectContext:q,SVGCollector:L,Segment:v,Sequence:P,Shape:S,ShapeContext:b,ShapeSystem:R,ShapesContext:M,SquareContext:U,TessellationSystem:A,TriangleContext:J,Vector2:c,Vertex:x,palette:et,quiltBlockTemplates:nt,sequence:F,shape:ht,system:{grid(y){return D.create(y)},tessellation(y){return A.create(y)},fromShape(y,t){return new R(y,t)},lsystem(y){return O.create(y)},quilt(y){return new tt(y)}}});function lt(){const y=new Set,t=new WeakSet,e=new WeakSet;function s(d){return new Proxy(d,{get(a,f,p){const g=Reflect.get(a,f,p);return typeof g=="function"?function(..._){const m=g.apply(a,_);return m instanceof b?(y.add(m),i(m)):m instanceof M?(y.add(m),n(m)):m}:g}})}function n(d){return new Proxy(d,{get(a,f,p){const g=Reflect.get(a,f,p);return typeof g=="function"?function(..._){const m=g.apply(a,_);return m instanceof b?(t.add(a),y.add(m),i(m)):m instanceof M?(m!==a&&t.add(a),y.add(m),n(m)):m}:g instanceof N||g instanceof X?s(g):g}})}function i(d){return new Proxy(d,{get(a,f,p){const g=Reflect.get(a,f,p);return typeof g=="function"?function(..._){const m=g.apply(a,_);return m instanceof b?(m!==a&&t.add(a),y.add(m),i(m)):m instanceof M?(t.add(a),y.add(m),n(m)):m instanceof z?(t.add(a),h.push(m),r(m)):m}:g instanceof N||g instanceof X?s(g):g}})}function o(d,a){return new Proxy(d,{get(f,p,g){const _=Reflect.get(f,p,g);return typeof _=="function"?function(...m){const w=_.apply(f,m);return w===f?o(w):w instanceof b?(t.add(f),y.add(w),i(w)):w instanceof M?(t.add(f),y.add(w),n(w)):w}:_ instanceof N||_ instanceof X?s(_):_}})}function r(d){return new Proxy(d,{get(a,f,p){const g=Reflect.get(a,f,p);return typeof g=="function"?function(..._){const m=g.apply(a,_);return m instanceof z?(h.push(m),r(m)):m instanceof b||m instanceof M?o(m):m}:g}})}const h=[];return{autoShape:{circle:()=>{const d=new K;return y.add(d),i(d)},rect:()=>{const d=new q;return y.add(d),i(d)},square:()=>{const d=new U;return y.add(d),i(d)},hexagon:()=>{const d=new Q;return y.add(d),i(d)},triangle:()=>{const d=new J;return y.add(d),i(d)}},autoSystem:{grid:d=>{const a=D.create(d);return h.push(a),a},tessellation:d=>{const a=A.create(d);return h.push(a),a},fromShape:(d,a)=>{const f=new R(d,a);return h.push(f),f},lsystem:d=>{const a=O.create(d);return h.push(a),a},quilt:d=>{const a=new tt(d);return h.push(a),a}},shapeRegistry:y,createdSystems:h,consumedContexts:t,consumedSystems:e}}function ut(y){const t=y instanceof Error?y.message:String(y);if(y instanceof Error&&y.stack){const e=y.stack.match(/<anonymous>:(\d+):(\d+)/);if(e)return{message:t,line:parseInt(e[1],10),column:parseInt(e[2],10)};const s=y.stack.match(/eval code:(\d+):(\d+)/);if(s)return{message:t,line:parseInt(s[1],10),column:parseInt(s[2],10)};const n=y.stack.match(/Function:(\d+):(\d+)/);if(n)return{message:t,line:parseInt(n[1],10),column:parseInt(n[2],10)};const i=y.stack.match(/:(\d+):(\d+)/);if(i){const o=parseInt(i[1],10);if(o>0&&o<1e3)return{message:t,line:o,column:parseInt(i[2],10)}}}return{message:t,line:1}}self.onmessage=y=>{const{type:t,code:e,autoRender:s=!0}=y.data;if(t==="execute")try{const{autoShape:n,autoSystem:i,shapeRegistry:o,createdSystems:r,consumedContexts:h,consumedSystems:l}=lt(),u=new L;u.setRenderMode("glass");let d=!1,a="",f=null;const p={...ct,shape:n,system:i,svg:u,Sequence:P,Palette:T,sequence:F,palette:et,render:G=>{d=!0;const $=G||u;a=$.toString({width:400,height:400,margin:20,autoScale:!1});const C=$.stats;C&&(f={shapes:C.shapes,segments:C.segments})}},g=Object.keys(p),_=Object.values(p),w=new Function(...g,e)(..._);if(typeof w=="string"&&w.includes("<svg"))a=w;else if(s&&(o.size>0||r.length>0)&&!d){for(const $ of r)!l.has($)&&typeof $.stamp=="function"&&$.stamp(u);for(const $ of o)!h.has($)&&typeof $.stamp=="function"&&$.stamp(u);a=u.toString({width:400,height:400,margin:20,autoScale:!1});const G=u.stats;G&&(f={shapes:G.shapes,segments:G.segments})}else if(!d)if((u.length||0)>0){a=u.toString({width:400,height:400,margin:20,autoScale:!1});const $=u.stats;$&&(f={shapes:$.shapes,segments:$.segments})}else a="",f=null;let k;if(a&&u){const G=u.paths||[],$={minX:u.minX??0,minY:u.minY??0,maxX:u.maxX??0,maxY:u.maxY??0};k={paths:G,bounds:$}}self.postMessage({type:"success",svg:a,stats:f,collectorData:k})}catch(n){console.error("Worker execution error:",n);const i=ut(n);self.postMessage({type:"error",error:i.message,line:i.line,column:i.column})}}})();
